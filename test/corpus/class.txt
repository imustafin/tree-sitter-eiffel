===
Notes
===
note
  demo_note: True
  multi_note: True, False
class DEMO_CLASS
note
  feature_note: True
invariant
  note
    invriant_note: True
end
---
(source_file
  (class_declaration
    notes: (notes
      (note_entry
        (identifier)
        (note_values
          (note_item (boolean_constant))))
      (note_entry
        (identifier)
        (note_values
          (note_item (boolean_constant))
          (note_item (boolean_constant)))))
    (class_name (identifier))
    (notes
      (note_entry
        (identifier)
        (note_values (note_item (boolean_constant)))))
    (invariant)
    (notes
      (note_entry
        (identifier)
        (note_values (note_item (boolean_constant)))))))

===
Mark
===
deferred class DEMO end
---
(source_file
  (class_declaration
    mark: (header_mark)
    (class_name (identifier))))

===
Obsolete
===
class A
  obsolete "msg"
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (obsolete (manifest_string (basic_manifest_string (string_content))))))

===
Class invariant
===
class A
invariant
  True
  tagged: -- Tagged comment
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (invariant
      (assertion_clause
        (unlabeled_assertion_clause
          (expression
            (special_expression (boolean_constant)))))
      (assertion_clause
        (tag_mark (identifier))
        (unlabeled_assertion_clause (comment))))))

===
Class. Formal generics
===
class A [frozen X, K -> {P, Q} create make, construct end, T -> S rename a as b end]
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (formal_generics
      (formal_generic (identifier))
      (formal_generic
        (identifier)
        (constraint
          (constraining_types
            (multiple_constraint
              (single_constraint (type (identifier)))
              (single_constraint (type (identifier)))))
          (constraint_creators (identifier) (identifier))))
      (formal_generic
        (identifier)
        (constraint
          (constraining_types
            (single_constraint
              (type (identifier))
              (rename
                (rename_pair
                  (identifier)
                  (extended_feature_name (identifier)))))))))))

===
Class. Inherit
===
class A
inherit {NONE}
  X Y Z

inherit
  W
    undefine a
    redefine c
    rename e as f
    export
      {ANY}
        -- Header comment
        all
    select g
    end
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (inheritance
      (non_conformance)
      (parent (class_type (class_name (identifier))))
      (parent (class_type (class_name (identifier))))
      (parent (class_type (class_name (identifier)))))
    (inheritance
      (parent
        (class_type (class_name (identifier)))
        (feature_adaptation
          (undefine (identifier))
          (redefine (identifier))
          (rename (rename_pair (identifier) (extended_feature_name (identifier))))
          (new_exports
            (new_export_item
              (clients (identifier))
              (header_comment)
              (export_all)))
          (select (identifier)))))))

===
Class. Create
===
class A
create {NONE} a
create b
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (creation_clause (clients (identifier)) (identifier))
    (creation_clause (identifier))))

===
Class. Converters
===
class A
convert
  a ({X, Y}),
  b: {G, H}
end
---
(source_file
  (class_declaration
    (class_name (identifier))
    (converters
      (converter (conversion_procedure (identifier) (type (identifier)) (type (identifier))))
      (converter (conversion_query (identifier) (type (identifier)) (type (identifier)))))))
